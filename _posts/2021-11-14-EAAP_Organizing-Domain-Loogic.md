---
title:  "[앤터프라이즈 애플리케이션 아키텍처 패턴 1-2]-Organizing Domain Logic"
search: false
categories: 
  - 앤터프라이즈 애플리케이션 아키텍처 패턴
last_modified_at: 2021-11-14T08:06:00-05:00
---

마틴파울러의 앤터프라이즈 애플리케이션 아키텍처 패턴을 읽고 정리하는 공간.
<figure>
	<a href="https://book.naver.com/bookdb/book_detail.naver?bid=9699564"><img src="/assets/images/Martin_Fowler.png"></a>
	<figcaption><a href="https://book.naver.com/bookdb/book_detail.naver?bid=9699564" title="네이버 책소개">네이버 책소개</a>.</figcaption>
</figure> 

도메인 논리는 주요 3가지 패턴으로 구분 된다.
1. 트랜잭션 스크립트
2. 도메인 모델
3. 테이블 모듈


## 1: 트랜잭션 스크립트
가장 간단한 절차적 패턴으로 프레젠테이션에서 입력을 받고, 유효성 검사와 계산을 통해 입력을 처리한 후 DB에 데이터를 적재하고 타 시스템의 작업을 호출한다.


개발자가 이해하기 쉽고 트랜잭션의 경계를 설정하기 쉽다는 장점이 있지만 각 Task마다 프로시저를 실행하므로 action이 비슷한 Task가 많다면 코드 중복이 상당할 수 있다는 단점이 있다.
공통적으로 사용되는 로직을 추출하여 서브루틴을 만드는 방법도 있지만 중복을 찾는 과정과 제거가 어려워 복잡한 도메인 논리를 Organizing하기는 적합하지 않다.

## 2: 도메인 모델
복잡한 논리는 '객체'를 통해 해결할 수 있고 객체지향적 방법을 적용한 패턴이 도메인 모델이다. 


도메인 모델 방식은 개발대상이 되는 '도메인 명사'(객체)를 바탕으로 class를 생성하고, 각각의 '도메인 명사'가 행해야 하는 기능(유효성 검사, 계산 등)을 class안에 포함하는 방식이다. 특정 class type에서 벗어나는 루틴의 경우 도메인 모델 메서드로 위임한다.

도메인모델은 복잡한 논리를 체계적으로 관리할 수 있는 패턴으로, 책 + 머리속에 떠오르는 장점은 3가지 정도가 있을 것 같다.

1. 한 번 모델을 구성하고 나면 타시스템 비슷한 객체에 거의 동일한 모델을 적용할 수 있다. ('QnA'는 어느 시스템이나 모델이 비슷하지 않을까..?)
2. 로직이 추가되는 경우 객체를 추가하는 등 유연한 대처가 가능하다.
3. 유지보수 시 프로그램 full scan이 필요없다. (특정 class만 수정)


하지만 단점도 존재하는데, 러닝커브가 상당히 크다는 점을 들 수 있다. 
한 시스템에서 객체로 구성할 수 있는 모든 '도메인 명사'(객체) 추출, As-Is 관계 판별, To-Be관계 정립에 많은 시간이 소요될 수 있고 능숙한 아키텍트 혹은 개발자가 없다면 도메인 모델을 구성하기는 어려울 수 있다.


## 테이블 모듈

테이블 모듈은 트랜잭션 스크립트와 도메인 모델의 중간적인 성격을 가지고 있다. 테이블을 기준으로 논리를 구성하기 때문에 구조를 만들고 중복제거가 수월하다는 장점이 있다. 또한 아키텍처의 나머지 부분과 잘 맞는다는 것인데(이것은 이해가 안간다..마음의 소리..).

도메인 모델과 차이점은 도메인 모델은 계약 별 객체가 생성되지만 테이블 모듈은 인스턴스가 하나이다. 쿼리를 수행하여 레코드 집합을 얻고 계약 전체에 대한 객체를 만든 후(맞나..?) ID값을 Method 파라미터로 전달하여 계약(ID)별 기능을 수행한다.(맞나...?) 



## 패턴선택

도메인 논리의 복잡도를 x축으로, 시간 및 노력 y축으로 놓고 애플리케이션이 어느 위치에 해당하는 지 파악하면 패턴 선택이 수월해진다. 

다만, 논리 복잡도는 개인의 주관적인 판단 등이 포함될 수 있고 정확한 객관적 지표가 없기 때문에 파악이 아주 힘들다. 


## 서비스 계층
도메인 논리를 처리하는 일반적인 방법은 도메인 계층을 둘로 나누는 것으로, 서비스 계층 기반이 되는 도메인 모델이나 테이블 모듈 위에 배치한다. 
서비스 계층은 명확한 API를 제공하며, 보안 기능을 넣기도 좋다. 서비스 계층을 사용할 때는 얼마나 많은 동작을 넣을지 결정하는 게 아주 중요하다.

가장 소극적 사례는 서비스 계층을 파사드로 만들고 모든 실제 동작을 기반 객체에 넣어, 서비스 계층이 파사드에 대한 호출을 하위 객체로 전달한다. 이 사례는 사용하기 쉬운 API를 제공한다.
반대되는 극단적 사례는 서비스 계층 안 트랜잭션 스크립트에 대부분의 비즈니스 논리를 넣는 것이다. 이러면 도메인 객체는 아주 단순하고 활성 레코드 같은 간단한 데이터 원본 계층을 사용할 수 있다.

두 방법에서 중간적인 성격을 가진 컨트롤러-엔티티 형식이 있다. 이 형식은 한 트랜잭션이나 유스 케이스에 적용되는 논리를 트랜잭션 스크립트에 넣는 것이며, 이를 컨트롤러나 서비스라고 한다. (MVC Controller와 다름)